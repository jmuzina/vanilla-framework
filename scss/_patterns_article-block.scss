/*
  @classreference
    Article block:
      .p-article-block:
        Container for blog article content
      .p-article-block__item:
        Individual content block within article block
      .p-article-block__image:
        An image within an article block
      .p-article-block__title:
        The title of the article block
      .p-article-block__metadata:
        Metadata container
      .p-article-block__metadata-item:
        Individual metadata item with middot separator between items
*/

@use 'sass:math';

@mixin vf-p-article-block {
  .p-article-block {
    display: grid;
    // image, title, desc/excerpt, metadata
    grid-row: span 4;
    grid-template-rows: subgrid;

    margin-bottom: $spv--small;

    // the section that wraps the items already has bottom padding defined, so the last row of items must have collapsed bottom margin to avoid duplicating spacing.
    // small screens - the last item gets collapsed bottom margin
    @media screen and (width < $threshold-4-small-4-med-col) {
      &:last-child {
        margin-bottom: 0;
      }
    }

    // medium screens - the last two items get collapsed bottom margin
    @media screen and ($threshold-4-small-4-med-col <= width < $threshold-4-8-col) {
      &:nth-last-child(-n + 2) {
        margin-bottom: 0;
      }
    }

    // large screen - all items get collapsed bottom margin
    @media screen and (width >= $threshold-4-8-col) {
      margin-bottom: 0;
    }
  }

  .p-article-block__image {
    margin-bottom: $spv--small;
  }

  .p-article-block__title {
    @extend %paragraph;
    //margin-top: 0;
    //font-size: #{map-get($settings-text-p, font-size)}rem;
    //line-height: map-get($settings-text-p, line-height);
    //margin-bottom: map-get($settings-text-p, sp-after) - map-get($settings-text-p, nudge);
    //padding-top: map-get($settings-text-p, nudge);
  }

  /**
 Non-empty block items have paragraph spacing.
 However, we need to avoid adding spacing to empty items (which we must always render in order to provide slots for dynamic rendering and to maintain subgrid alignment)
 So, we use :has() queries to selectively apply paragraph spacing only to non-empty items.
 :empty alone cannot be used because it doesn't match elements that contain only empty elements.

 So, we carefully target the leaf elements that might actually contain content.

 */
  /* First, group all your "non-empty" checks into a single :has()
    for clarity. This creates one selector for "non-empty-item".
  */
  .p-article-block__item:has(
  .p-article-block__title:not(:empty),
  .p-article-block__description:not(:empty),
  .article-author:not(:empty),
  .article-time:not(:empty)
) {
    /* Goal 1: Apply paragraph spacing to any non-empty item
      that has another non-empty item after it.

      The inner '&' here correctly refers to the full selector above.
      This translates to: NON_EMPTY_ITEM:has(~ NON_EMPTY_ITEM)
    */
    &:has(~ &) {
      @extend %paragraph;
    }

    & * {
      margin-top: 0;
      margin-bottom: 0;
      padding-top: 0;
      padding-bottom: 0;
    }

    /*
      Goal 2: Adjust margin on the last child.
      This rule is now separate from the sibling-matching logic.

      This translates to: NON_EMPTY_ITEM:last-child *:last-child
    */
    //&:last-child *:last-child {
    //  margin-bottom: #{$sp-unit - map-get($settings-text-p, nudge)};
    //}
  }

  /*
    Add a middot between non-empty metadata items
    The metadata-items are wrappers around child elements that are **always** rendered, so that dynamic content has slots to populate items into.
    We don't know at build time if there will be any content.
    So, we use :has() to target `p-article-block__metadata-item` elements that have at least one non-empty child element, without having to target any specific child selectors here.
    Note that this requires careful management of whitespace within the metadata items. Extra whitespace can cause elements with no children to be considered non-empty and unnecessarily render a middot.
   */
  .p-article-block__metadata-item:has(> *:not(:empty)) {
    @include vf-inline-list-item;

    margin-right: $sph--x-small;

    & ~ &::before {
      content: '\2022';
      position: relative;
    }
  }
}
